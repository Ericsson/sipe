 /**
 * @file sipe-cert-crypto-openssl.c
 *
 * pidgin-sipe
 *
 * Copyright (C) 2013 SIPE Project <http://sipe.sourceforge.net/>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 */

/**
 * Certificate routines implementation based on OpenSSL.
 */
#include <openssl/rsa.h>

#include <glib.h>

#include "sipe-backend.h"
#include "sipe-cert-crypto.h"

struct sipe_cert_crypto {
	RSA *key;
};

/*
 * This data structure is used in two different modes
 *
 *  a) certificate generated by the server from our Certificate Request
 *
 *     key              - reference to client RSA key, don't free!
 *     decoded          - certificate as OpenSSL data structure, must be freed
 *     raw              - certificate as DER encoded binary, must be freed
 *     length           - length of DER binary
 *
 *  b) server certificate
 *
 *     key              - reference to server public key, must be freed!
 *     decoded          - certificate as OpenSSL data structure, must be freed
 *     raw              - NULL
 *     length           - modulus length of server public key
 */
struct certificate_openssl {
	RSA *key;
	void *decoded; /* TBD <certificate> */
	guchar *raw;
	gsize length;
};

struct sipe_cert_crypto *sipe_cert_crypto_init(void)
{
	struct sipe_cert_crypto *scc = g_new0(struct sipe_cert_crypto, 1);

	/* RSA parameters - should those be configurable? */
	SIPE_DEBUG_INFO_NOFORMAT("sipe_cert_crypto_init: generate key pair, this might take a while...");
	scc->key = RSA_generate_key(2048, 65537, NULL, NULL);

	if (scc->key) {
		SIPE_DEBUG_INFO_NOFORMAT("sipe_cert_crypto_init: key pair generated");
		return(scc);
	}

	SIPE_DEBUG_ERROR_NOFORMAT("sipe_cert_crypto_init: key generation failed");
	g_free(scc);
	return(NULL);
}

void sipe_cert_crypto_free(struct sipe_cert_crypto *scc)
{
	if (scc) {
		if (scc->key)
			RSA_free(scc->key);
		g_free(scc);
	}
}


gchar *sipe_cert_crypto_request(struct sipe_cert_crypto *scc,
				const gchar *subject)
{
	gchar *base64                   = NULL;

	/* TBD */
	(void) scc;
	(void) subject;

	return(base64);
}

void sipe_cert_crypto_destroy(gpointer certificate)
{
	struct certificate_openssl *co = certificate;

	if (co) {
		/* imported server certificate - mode (b) */
		if (!co->raw)
			RSA_free(co->key);
		if (!co->decoded)
			/* TBD <destroy>(co->decoded); */{}
		g_free(co->raw);
		g_free(co);
	}
}

/* generates certificate_openssl in mode (a) */
gpointer sipe_cert_crypto_decode(struct sipe_cert_crypto *scc,
				 const gchar *base64)
{
	struct certificate_openssl *co = g_new0(struct certificate_openssl, 1);

	co->raw     = g_base64_decode(base64, &co->length);
	/* TBD 	co->decoded = <decode>(co->raw, co->length); */

	if (!co->decoded) {
		sipe_cert_crypto_destroy(co);
		return(NULL);
	}

	co->key = scc->key;

	return(co);
}

/* generates certificate_openssl in mode (b) */
gpointer sipe_cert_crypto_import(const guchar *raw,
				 gsize length)
{
	struct certificate_openssl *co = g_new0(struct certificate_openssl, 1);

	/* co->raw not needed as this is a server certificate */
	/* TBD 	co->decoded = <decode>(raw, length); */
	(void) raw;
	(void) length;

	if (!co->decoded) {
		sipe_cert_crypto_destroy(co);
		return(NULL);
	}

	/* TBD co->key = <extract publicKey>(co->decoded); */

	if (!co->key) {
		sipe_cert_crypto_destroy(co);
		return(NULL);
	}

	/* TBD co->length = <public key strength>(co->key); */

	return(co);
}

gboolean sipe_cert_crypto_valid(gpointer certificate,
				guint offset)
{
	struct certificate_openssl *co = certificate;

	if (!co)
		return(FALSE);

	/* TBD */
	(void) offset;
	return(FALSE);
}

guint sipe_cert_crypto_expires(gpointer certificate)
{
	/* TBD */
	(void) certificate;
	return(0);
}

gsize sipe_cert_crypto_raw_length(gpointer certificate)
{
	return(((struct certificate_openssl *) certificate)->length);
}

const guchar *sipe_cert_crypto_raw(gpointer certificate)
{
	return(((struct certificate_openssl *) certificate)->raw);
}

gpointer sipe_cert_crypto_public_key(gpointer certificate)
{
	return(((struct certificate_openssl *) certificate)->key);
}

gsize sipe_cert_crypto_modulus_length(gpointer certificate)
{
	return(((struct certificate_openssl *) certificate)->length);
}

gpointer sipe_cert_crypto_private_key(gpointer certificate)
{
	return(((struct certificate_openssl *) certificate)->key);
}

/* Create test certificate for internal key pair (ONLY USE FOR TEST CODE!!!) */
gpointer sipe_cert_crypto_test_certificate(struct sipe_cert_crypto *scc)
{
	/* TBD? */
	(void) scc;
	return(NULL);
}

/*
  Local Variables:
  mode: c
  c-file-style: "bsd"
  indent-tabs-mode: t
  tab-width: 8
  End:
*/
